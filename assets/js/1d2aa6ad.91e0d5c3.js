"use strict";(self.webpackChunknotes_template=self.webpackChunknotes_template||[]).push([[1641],{2878:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Language","href":"/language-automaton-and-compiler/docs/language","docId":"language","unlisted":false},{"type":"link","label":"Grammar and Language Hierarchy","href":"/language-automaton-and-compiler/docs/grammar-and-language-hierarchy","docId":"grammar-and-language-hierarchy","unlisted":false},{"type":"category","label":"Regular Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Deterministic Finite Automaton","href":"/language-automaton-and-compiler/docs/regular-language/dfa","docId":"regular-language/dfa","unlisted":false},{"type":"link","label":"Non-Deterministic Finite Automaton","href":"/language-automaton-and-compiler/docs/regular-language/nfa","docId":"regular-language/nfa","unlisted":false},{"type":"link","label":"Non-Deterministic Finite Automaton With Empty Transitions","href":"/language-automaton-and-compiler/docs/regular-language/epsilon-nfa","docId":"regular-language/epsilon-nfa","unlisted":false},{"type":"link","label":"Regular Expression","href":"/language-automaton-and-compiler/docs/regular-language/regular-expression","docId":"regular-language/regular-expression","unlisted":false},{"type":"link","label":"Left Linear Grammar","href":"/language-automaton-and-compiler/docs/regular-language/left-linear-grammar","docId":"regular-language/left-linear-grammar","unlisted":false},{"type":"link","label":"Pumping Lemma of Regular Languages","href":"/language-automaton-and-compiler/docs/regular-language/pumping-lemma","docId":"regular-language/pumping-lemma","unlisted":false}],"href":"/language-automaton-and-compiler/docs/category/regular-language"},{"type":"category","label":"Context Free Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Context Free Grammar","href":"/language-automaton-and-compiler/docs/context-free-language/context-free-grammar","docId":"context-free-language/context-free-grammar","unlisted":false},{"type":"link","label":"LL(1) Grammar","href":"/language-automaton-and-compiler/docs/context-free-language/left-starting-leftmost-one-grammar","docId":"context-free-language/left-starting-leftmost-one-grammar","unlisted":false},{"type":"link","label":"Push-Down Automaton","href":"/language-automaton-and-compiler/docs/context-free-language/push-down-automaton","docId":"context-free-language/push-down-automaton","unlisted":false},{"type":"link","label":"LR Grammar","href":"/language-automaton-and-compiler/docs/context-free-language/left-starting-rightmost-grammar","docId":"context-free-language/left-starting-rightmost-grammar","unlisted":false}],"href":"/language-automaton-and-compiler/docs/category/context-free-language"},{"type":"category","label":"Compiler","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Compiler Architecture","href":"/language-automaton-and-compiler/docs/compiler/context-free-grammar","docId":"compiler/context-free-grammar","unlisted":false}],"href":"/language-automaton-and-compiler/docs/category/compiler"},{"type":"category","label":"Context Sensitive Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"context-sensitive-grammar","href":"/language-automaton-and-compiler/docs/context-sensitive-language/context-sensitive-grammar","docId":"context-sensitive-language/context-sensitive-grammar","unlisted":false}],"href":"/language-automaton-and-compiler/docs/category/context-sensitive-language"},{"type":"category","label":"Turning Machine","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"turing-machine","href":"/language-automaton-and-compiler/docs/turing-mahcine/turing-machine","docId":"turing-mahcine/turing-machine","unlisted":false}],"href":"/language-automaton-and-compiler/docs/category/turning-machine"}]},"docs":{"compiler/context-free-grammar":{"id":"compiler/context-free-grammar","title":"Compiler Architecture","description":"After we have studied CFG, we put it into the use of the compiler. All programming languages are CFG. And most programming languages are designed to be $LR(1)$ or $SLR(1)$.","sidebar":"tutorialSidebar"},"context-free-language/context-free-grammar":{"id":"context-free-language/context-free-grammar","title":"Context Free Grammar","description":"Context free grammar allows rules in the form of,","sidebar":"tutorialSidebar"},"context-free-language/left-starting-leftmost-one-grammar":{"id":"context-free-language/left-starting-leftmost-one-grammar","title":"LL(1) Grammar","description":"For some unambiguous language, there is a way that we can scan the sentence from left to right one by one, and find the only possible derivation based on the next one character (if there exists two, it\'s ambiguous). This is called an $LL(1)$ grammar. The first $L$ stands for left starting. The second $L$ stands for leftmost derivation. $1$ means that the grammar only need to look ahead of one symbol to know which rule to apply.","sidebar":"tutorialSidebar"},"context-free-language/left-starting-rightmost-grammar":{"id":"context-free-language/left-starting-rightmost-grammar","title":"LR Grammar","description":"$LL(1)$ language has good enough properties for us to write a simple parser. However, $LL(1)$ still has too many restrictions and sometimes not expressive enough. An alternative approach would be to use $LR(1)$ grammar, which is left starting, rightmost derivation and look ahead of one symbol. Using $LR(1)$, for any given sequence, we can derivate a leftmost reduction path, thus constructing a parse tree using rightmost derivation.","sidebar":"tutorialSidebar"},"context-free-language/push-down-automaton":{"id":"context-free-language/push-down-automaton","title":"Push-Down Automaton","description":"Push-Down Automaton (PDA) is an automaton that can test a context-free language. Just like how NFA can test a regular language. PDA is the device we later will use for $LR$ grammar parsing.","sidebar":"tutorialSidebar"},"context-sensitive-language/context-sensitive-grammar":{"id":"context-sensitive-language/context-sensitive-grammar","title":"context-sensitive-grammar","description":"","sidebar":"tutorialSidebar"},"grammar-and-language-hierarchy":{"id":"grammar-and-language-hierarchy","title":"Grammar and Language Hierarchy","description":"Grammar","sidebar":"tutorialSidebar"},"language":{"id":"language","title":"Language","description":"Symbol","sidebar":"tutorialSidebar"},"regular-language/dfa":{"id":"regular-language/dfa","title":"Deterministic Finite Automaton","description":"Deterministic Finite automaton (DFA) is a machine that can recognize a regular language based on its grammar.","sidebar":"tutorialSidebar"},"regular-language/epsilon-nfa":{"id":"regular-language/epsilon-nfa","title":"Non-Deterministic Finite Automaton With Empty Transitions","description":"We have nullable regular languages, and so we have nullable NFA, that is, NFA with empty transitions, also called e-NFA ($\\\\epsilon$-NFA).","sidebar":"tutorialSidebar"},"regular-language/left-linear-grammar":{"id":"regular-language/left-linear-grammar","title":"Left Linear Grammar","description":"This is a bit of a detour. Previously, we defined regular grammar as,","sidebar":"tutorialSidebar"},"regular-language/nfa":{"id":"regular-language/nfa","title":"Non-Deterministic Finite Automaton","description":"Non-Deterministic Finite automaton (NFA) is an extension to the DFA that is simpler to design. It can be converted into a DFA and thus, it also accepts a regular language.","sidebar":"tutorialSidebar"},"regular-language/pumping-lemma":{"id":"regular-language/pumping-lemma","title":"Pumping Lemma of Regular Languages","description":"The pumping lemma for regular languages is a lemma that describes an essential property of all regular languages. Informally, it says that all sufficiently long strings in a regular language may be pumped\u2014that is, have a middle section of the string repeated an arbitrary number of times\u2014to produce a new string that is also part of the language.","sidebar":"tutorialSidebar"},"regular-language/regular-expression":{"id":"regular-language/regular-expression","title":"Regular Expression","description":"Regular expression is a simpler way to describe a regular language.","sidebar":"tutorialSidebar"},"turing-mahcine/turing-machine":{"id":"turing-mahcine/turing-machine","title":"turing-machine","description":"","sidebar":"tutorialSidebar"}}}}')}}]);